#!/bin/sh

set -eu

program_name="spawn"

FS=$(printf '\nx'); FS=${FS%x}
S=$(printf '\t')
E=
Q='{QUOTE}'

xsock_dir='/tmp/.X11-unix'
mountpoints=

# saving the stderr to allow showing error messages from subshells
exec 3>&2

show_usage() {
    cat <<EOF
Usage: $program_name [OPTIONS...] <name|directory> [COMMAND [ARGS...]]

  -h                    Show usage information
  --help                Show full help
  -r|--as-root          Use superuser inside the spawned root
  -n|--dry-run          Do not run any privileged commands - only print them
  -i|--image            An image or Docker container name to run
  -d|--dir              A directory to spawn or chroot into
  -u|--user <name>      Assume <name> user inside the container
  --arch <arch>         Set architecture reported by uname(2)
  --bind-home <dir>     Bind the specified directory as a user's home directory
  --bind-dir <dir>      Mount the specified directory inside the root
  --with-ssh-agent      Pass SSH_AUTH_SOCK variable and bind the socket
  --with-x11            Pass DISPLAY, XAUTHORITY and bind $xsock_dir
  --with-pulseaudio     Set PULSE_SERVER and pass Pulseaudio socket
  --to-stderr           Redirect all container command output to stderr
  --share-devices       Share devices with the host
  --using-docker        Use Docker to spawn the named container
  --using-nspawn        Use 'systemd-nspawn' to chroot
  --unlock              Remove the lock file
  --cleanup             Release stale mount points and unlock

EOF
}

show_help() {
    cat <<EOF
Usage: $program_name [OPTIONS...] <name|directory> [COMMAND [ARGS...]]

  Spawns a new container and configures a shared environment.

OPTIONS

  -h                    Show usage information
  --help                Show full help
  -r|--as-root          Use superuser inside the spawned root
  -n|--dry-run          Do not run any privileged commands - only print them
  -i|--image            An image or Docker container name to run
  -d|--dir              A directory to spawn or chroot into
  -u|--user <name>      Assume <name> user inside the container
  --arch <arch>         Set architecture reported by uname(2)
  --bind-home <dir>     Bind the specified directory as a user's home directory
  --bind-dir <dir>      Mount the specified directory inside the root
  --with-ssh-agent      Pass SSH_AUTH_SOCK variable and bind the socket
  --with-x11            Pass DISPLAY, XAUTHORITY and bind $xsock_dir
  --with-pulseaudio     Set PULSE_SERVER and pass Pulseaudio socket
  --to-stderr           Redirect all container command output to stderr
  --share-devices       Share devices with the host
  --using-docker        Use Docker to spawn the named container
  --using-nspawn        Use 'systemd-nspawn' to chroot
  --unlock              Remove the lock file
  --cleanup             Release stale mount points and unlock

SYNOPSIS

  The 'spawn' script runs the named Docker container or spawns into the
  specified directory. If neither '--image' nor '--dir' option is provided then
  the first non-option argument which is not a parameter to some other option
  is assumed to specify what to spawn. If it points to an existing directory
  then the script assumes you want to nspawn and run a container otherwise. Use
  the '--' to explicitly mark the end of spawn's arguments.

  If the next argument after the name or '--' does not start with a '-' it,
  along with the remaining command line will be passed to the spawned
  environment as the command to run. Otherwise, if the next argument after the
  name or '--' does start with a '-' it and the rest will be passed as options
  to the underlying driver (docker run / systemd-nspawn). Use the '--' to
  separate the arguments from the command in this case. The argument list could
  be empty, use the '--' immediately after the name to pass the command
  starting with '-' directly to the spawned environment (e.g. to container's
  entrypoint script).

  Specifying an '--image' option requests to spawn a Docker container,
  specifying a '--dir' option requests to spawn chroot using the systemd-nspawn
  if it is found. Specifying '--using-*' option overrides any other heuristic
  for determining spawn type including the existence of the '--image', '--dir'
  or checking for an existing directory.

  If no user is specified the script will attempt to map the current user to
  the spawned environment. In the case of root directory it will find out the
  user info from root's /etc/passwd but in the case of containers it will not
  be able to guess the username, so if it differs from the local username it is
  necessary to set it explicitly.

  Use the '--bind-home' option to mount the specified directory as a user's home
  directory inside the chroot. For example, if you run:

      spawn --bind-home $HOME/somedir root

  The directory '$HOME/somedir' will become '/home/dev' inside the spawned
  chroot (assuming the default 'dev' user is not overridden). Use this to have a
  separate clean profile and settings from the host or to share the same home
  directory between different chrooted environments.

  Use the '--bind-dir' option to mount the specified directory inside the chroot
  at the same path as outside. Run build commands relative to this directory to
  have compile_commands.json generated with the absolute paths directly usable
  by editor and language servers outside of the chrooted environment. After
  spawning the chroot it will be the current working directory and also
  available as '\$WD' in the environment. It can be the same directory which is
  specified for '--bind-home'.

  Use the '--unlock' option to remove stale lock files from the root directory
  after an unexpected system shutdown, for example.

  The '--cleanup' option can be used to unmount the directories left by other
  spawn invocations.

  If either '--unlock' or '--cleanup' is specified all other options are
  ignored, the script exits immediately after the cleanup.

NOTE

  If you get "Connection failure: Protocol error" error or silent audio when
  trying to run PulseAudio applications inside the chroot, you need to disable
  communication through shared memory for the client. Add:

    enable-shm = no

  to "/etc/pulse/client.conf" inside the root directory.

EOF
}

parse_command_line() {
    local name=

    while [ $# -gt 0 ]; do
        case $1 in
            --) shift; break ;;
            -h) show_usage; exit ;;
            --help) show_help; exit ;;
            -i|--image)
                spawn_image=${2-}; shift ;;
            -d|--dir)
                spawn_dir=${2-}; shift ;;
            -n|--dry-run) E='echo' ;;
            -r|--as-root)
                spawn_user_arg='root' ;;
            -u|--user)
                spawn_user_arg=${2-}; shift ;;
            --uid)
                spawn_user_uid=${2-}; shift ;;
            --gid)
                spawn_user_gid=${2-}; shift ;;
            --as-admin)
                spawn_cap_admin=1 ;;
            --name)
                spawn_name=${2-}; shift ;;
            --arch)
                spawn_arch=${2-}; shift ;;
            --bind-home)
                bind_home=${2-}; shift ;;
            --bind-dir|--bind)
                bind_dir_args=${bind_dir_args-}${FS}${2-}; shift ;;
            --with-ssh-agent)
                with_ssh_agent=1 ;;
            --with-ssh-dir)
                with_ssh_dir=1 ;;
            --with-x11)
                with_x11=1 ;;
            --with-pulseaudio)
                with_pulseaudio=1 ;;
            --to-stderr)
                to_stderr=1 ;;
            --share-ipc)
                share_ipc=1 ;;
            --share-gpu)
                share_gpu=1 ;;
            --share-devices)
                share_devices=1 ;;
            --using-docker)
                spawn_type='docker' ;;
            --using-podman)
                spawn_type='podman' ;;
            --using-nspawn)
                spawn_type='nspawn' ;;
            --unlock)
                do_unlock=1 ;;
            --cleanup)
                do_cleanup=1 ;;
            --debug-command)
                debug_command=1 ;;
            -*)
                die "unrecognized argument: $1" ;;
            *)
                if [ -z "${spawn_image-}" ] && [ -z "${spawn_directory-}" ]
                then
                    name=${1}; shift
                fi
                break ;;
        esac
        shift
    done

    if [ "${1-}" ] && [ "${1}" != "${1#-}" ]; then
        while [ $# -gt 0 ]; do
            case $1 in
                --) shift; break ;;
                 *) spawn_args=${spawn_args-}${S}${1} ;;
            esac
            shift
        done
    fi

    while [ $# -gt 0 ]; do
        spawn_command=${spawn_command-}${S}${1}
        shift
    done

    case ${spawn_type-} in
        nspawn)
            : ${spawn_dir=$name} ;;
        docker|podman)
            : ${spawn_image=$name} ;;
        '')
            if [ "${spawn_image-}" ]; then
                spawn_type='docker'
            elif [ "${spawn_dir-}" ]; then
                spawn_type='dir...'
            elif [ -d "$name" ]; then
                spawn_type='dir...'
                spawn_dir=${name}
            else
                spawn_type='docker'
                spawn_image=${name}
            fi ;;
    esac

    if [ "$spawn_type" = 'dir...' ]; then
        if [ "$(command -v systemd-nspawn)" ]; then
            spawn_type='nspawn'
        fi
    fi

    spawn_args=${spawn_args+${spawn_args#$S}}
    spawn_command=${spawn_command+${spawn_command#$S}}
    bind_dir_args=${bind_dir_args+${bind_dir_args#$FS}}

    if [ "${debug_command:-}" ]; then
        echo "spawn_image: $spawn_image"
        echo "spawn_args: $spawn_args"
        echo "spawn_command: $spawn_command"
    fi
}

validate_environment() {
    if [ -z "${spawn_image-}" -a -z "${spawn_dir-}" ]; then
        die "neither container image nor directory is specified"
    fi
    case ${spawn_type-} in
        nspawn)
            [ "${spawn_dir-}" ] ||
                die "root directory is not specified"
            [ -d "$spawn_dir" ] ||
                die "the root directory '$spawn_dir' is not exists"
            [ -f "$spawn_dir/etc/passwd" ] ||
                die "/etc/passwd is not exists in '$spawn_dir'"
            ;;
        docker)
            [ "$(command -v docker)" ] ||
                die "docker command was not found"
            [ "${spawn_image-}" ] ||
                die "container name is not specified"
            if [ "${spawn_image-}" ]; then
                docker_image_exists "$spawn_image" ||
                    die "the container image '$spawn_image' does not exist"
            fi
    esac

    case ${spawn_type-} in
        nspawn)
            [ "$(command -v systemd-nspawn)" ] ||
                die "systemd-nspawn command was not found"
            ;;
    esac

    case ${spawn_type-} in
        nspawn)
            if [ "${share_devices-}" ]; then
                die "the '--share-devices' option is not supported for nspawn"
            fi ;;
    esac
}

die() {
    local sts=$?
    [ $sts = 0 ] && sts=2
    [ $# = 0 ] || echo $program_name error: $* >&3
    exit $sts
}

warn() {
    echo "$program_name warning: $*"
}

su_run() {
    if [ "${euid:?}" = "0" ]; then
        $E "$@"
    else
        if [ -t 0 ]; then
            $E sudo "$@"
        else
            $E sudo -A "$@"
        fi
    fi
}

is_number() {
    case $1 in
        ''|*[!0-9]*) return 1 ;;
        *) return 0 ;;
    esac
}

escape_quote() {
    local arg= result=
    for arg; do
        arg=$(printf "%s" "$arg" | sed "s/'/'\\\''/g")
        result="$result${S}$arg"
    done
    result=${result#${S}}
    printf '%s' "$result"
}

docker_image_exists() {
    [ "$(command -v docker)" ] || return
    # it seems like the image name could be basically anything, some scripts
    # create images which look like hostnames, so any heuristic here is futile
    docker images --format '{{.Repository}}' | grep -q "^${1}$" ||
        docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "^${1}$"
}

find_passwd_user_info() {
    local passwd="${1}" field="${2}" user="${3}"
    [ -f "${passwd}" ] || return
    while IFS=: read -r name pass uid gid gecos home shell; do
        if is_number "$user" && [ "$user" = "$uid" ] ||
           [ "$user" = "$name" ]
        then
            eval "echo \$$field"
            break
        fi
    done < "$passwd"
}

find_user_info() {
    local field="${1}" user_arg="${2}" group_arg="${3-}"
    case $user_arg in
        0|root)
            case $field in
                name) echo root ;;
                 uid) echo 0 ;;
                 gid) echo 0 ;;
                home) echo /root ;;
            esac ;;
        *)
            if [ "${spawn_dir-}" ]; then
                find_passwd_user_info "${spawn_dir}/etc/passwd" "$field" "$user_arg"
            else
                case $field in
                    name) is_number "$user_arg" || echo "$user_arg" ;;
                     uid) is_number "$user_arg" && echo "$user_arg" ;;
                     gid) is_number "$group_arg" && echo "$group_arg" ;;
                    home) is_number "$user_arg" || echo "/home/$user_arg" ;;
                esac
            fi ;;
    esac
}

get_host_xdg_config_dir() {
    echo "${XDG_CONFIG_HOME:-${HOME:?}/.config}${1:+/$1}"
}

get_host_xdg_runtime_dir() {
    echo "${XDG_RUNTIME_DIR:-/run/user/${host_user_uid}}"
}

get_target_xdg_runtime_dir() {
    echo "/run/user/${spawn_user_uid}"
}

get_pa_socket() {
    if [ "$(command -v pactl)" ]; then
        pactl info 2>/dev/null | \
            awk '/Server String: / { print $3 }' | \
            sed 's/^unix://'
    fi
}

get_command() {
    local IFS="$S" cd_cmd
    if [ "${spawn_wd-}" ]; then
        cd_cmd="cd \"$(escape_quote "$spawn_wd")\""
    else
        cd_cmd="cd"
    fi
    if [ -z "${spawn_command-}" ]; then
        spawn_command="exec${S}/bin/bash${S}-l"
    fi
    cat <<EOF
/bin/sh -c 'IFS=$(printf \"\\t\"); cmd="$(escape_quote "$spawn_command")"; $cd_cmd && \$cmd'
EOF
}

root_mkdir() {
    local uid="$spawn_user_uid" gid="$spawn_user_gid"
    su_run install -o "${uid:?}" -g "${gid:?}" ${2:+"-m$2"} -d "${spawn_dir:?}${1:?}"
}

add_mountpoints() {
    for arg; do
        mountpoints="${arg}${S}${mountpoints}"
    done
}

bind_mount() {
    su_run mount --bind "${1:?}" "${2:?}"
    add_mountpoints "$2"
}

bind_file() {
    su_run touch "${2:?}"
    bind_mount "$1" "$2"
}

bind_dir() {
    su_run mkdir -p "$2"
    bind_mount "$1" "$2"
}

try_umount() {
    local path="${1:?}" arg="${2-}"
    if su_run mountpoint -q "$path"; then
        su_run umount $arg "$path" || true
    fi
}

get_lock_filename() {
    local dir="$(dirname "${1:?}")" name="$(basename "${1:?}")"
    echo "${dir:?}/.${program_name:?}.${name:?}.lock"
    # the scheme used by systemd-nspawn
    # echo "${dir}/.#${name}.lck"
}

is_locked() {
    test -f "$(get_lock_filename "${1:?}")"
}

lock_dir() {
    su_run touch "$(get_lock_filename "${1:?}")"
}

unlock_dir() {
    su_run rm -f "$(get_lock_filename "${1:?}")"
}

add_user_arg() {
    local _A=

    [ "${spawn_user_arg-}" ] || return 0

    case $spawn_type in
        nspawn|docker|podman)
            _A="--user=$spawn_user_arg" ;;
    esac

    eval "${1}=\"\$${1}$S$_A\""
}

make_setarch() {
    case ${spawn_arch-} in
        x86|i?86)
            echo "linux32" ;;
        x86-64|x86_64|amd64)
            echo "linux64" ;;
        '') ;;
         *) die "unknown arch '$spawn_arch'" ;;
    esac
}

make_env_arg() {
    local value="$1"
    case $spawn_type in
        nspawn) echo "--setenv=$value" ;;
        docker|podman) echo "--env=$value" ;;
    esac
}

make_bind_arg() {
    local from="${1}" to="${2}" opt="${3-}" value
    value=${from}:${to}${opt:+:$opt}
    case $spawn_type in
        nspawn) echo "--bind=$value" ;;
        docker|podman) echo "--volume=$value" ;;
    esac
}

setup_caps() {
    local _A=

    if [ "${spawn_cap_admin:-}" ]; then
        _A="$_A$S--cap-add=SYS_ADMIN"
    fi

    eval "${1}=\"\$${1}$S$_A\""
}

setup_devices() {
    local _A=

    if [ "${share_gpu:-}" ]; then
        _A="$_A$S--device=/dev/dri/card0"
    fi

    eval "${1}=\"\$${1}$S$_A\""
}

setup_runtime_env() {
    local _A= uid= gid= runtime_dir=

    [ -z "${with_ssh_agent-}"  ] &&
    [ -z "${with_x11-}"        ] &&
    [ -z "${with_pulseaudio-}" ] &&
        return 0

    runtime_dir=$(get_host_xdg_runtime_dir)

    target_runtime_dir=$(get_target_xdg_runtime_dir)
    spawn_runtime_dir=$(mktemp -dp "/tmp" spawn.XXXXXXXXXX)

    case $spawn_type in
        *)
            _A="$_A$S$(make_bind_arg "$spawn_runtime_dir" "$target_runtime_dir")"
            ;;

    esac

    _A="$_A$S$(make_env_arg "XDG_RUNTIME_DIR=$target_runtime_dir")"

    eval "${1}=\"\$${1}$S$_A\""
}

setup_system_env() {
    local SYS_A=

    case $spawn_type in
        nspawn)
            SYS_A="$SYS_A$S$(make_bind_arg "/etc/resolv.conf" "/etc/resolv.conf")"
            ;;
    esac

    if [ -f /etc/localtime ]; then
        case $spawn_type in
            nspawn)
                SYS_A="$SYS_A$S$(make_bind_arg "/etc/localtime" "/etc/localtime")"
                ;;
        esac
    fi

    eval "${1}=\"\$${1}$S$SYS_A\""
}

setup_ssh_agent_env() {
    local SSH_A= uid=

    [ "${with_ssh_agent-}" ] || return 0

    [ "${SSH_AUTH_SOCK-}" ] ||
        die "passing of SSH agent is enabled but SSH_AUTH_SOCK is not set"
    [ -S "$SSH_AUTH_SOCK" ] ||
        die "$SSH_AUTH_SOCK socket is not exists or is not a socket"

    uid=$spawn_user_uid

    SSH_A="$SSH_A$S$(make_env_arg "SSH_AUTH_SOCK=$target_runtime_dir/ssh")"

    case $spawn_type in
        *)
            SSH_A="$SSH_A$S$(make_bind_arg "$SSH_AUTH_SOCK" "$target_runtime_dir/ssh")"
            ;;
    esac

    if [ "${euid:?}" != "$uid" ]; then
        warn "the current effective user ID ($euid) does not match the user \
ID inside the container ($uid) but SSH agent socket sharing is requested -- \
changing $SSH_AUTH_SOCK mode to world writeable/readable (666)"
        chmod 666 "$SSH_AUTH_SOCK"
    fi

    eval "${1}=\"\$${1}$S$SSH_A\""
}

setup_ssh_dir_env() {
    local SSH_A= uid=

    [ "${with_ssh_dir-}" ] || return 0

    [ "${spawn_home-}" ] ||
        die "unable to automatically determine user's home directory inside the \
spawned container to map the .ssh directory, please specify username with the \
--user option"

    case $spawn_type in
        docker|podman)
            SSH_A="$SSH_A$S$(make_bind_arg "$HOME/.ssh" "$spawn_home/.ssh")"
            ;;
    esac

    eval "${1}=\"\$${1}$S$SSH_A\""
}

setup_x11_env() {
    local X11_A= xauth_file= xsock_file=

    [ "${with_x11-}" ] || return 0

    [ "${DISPLAY-}" ] ||
        die "passing of X11 environment is enabled but DISPLAY is not set"
    [ -d "$xsock_dir" ] ||
        die "X11 socket directory '$xsock_dir' is not exists"

    # disable Qt's usage of shared memory when not sharing IPC
    if [ -z "${share_ipc:-}" ]; then
        X11_A="$X11_A$S$(make_env_arg QT_X11_NO_MITSHM=1)"
    fi

    xauth_file="$spawn_runtime_dir/Xauthority"
    touch "$xauth_file"
    extract_xauth "$xauth_file"
    chmod 666 "$xauth_file"

    X11_A="$X11_A$S$(make_env_arg "DISPLAY=$DISPLAY")"
    X11_A="$X11_A$S$(make_env_arg "XAUTHORITY=$target_runtime_dir/Xauthority")"

    xsock_file="$xsock_dir/X${DISPLAY#:}"

    case $spawn_type in
        *)
            X11_A="$X11_A$S$(make_bind_arg "$xsock_file" "$xsock_file")"
            ;;
    esac

    eval "${1}=\"\$${1}$S$X11_A\""
}

setup_pa_env() {
    local PA_A= sock_file= cookie_file=

    [ "${with_pulseaudio-}" ] || return 0

    sock_file=$(get_pa_socket)

    [ "$sock_file" ] ||
        die "passing of PulseAudio is enabled but the socket could not be found"
    [ -S "$sock_file" ] ||
        die "PulseAudio socket '$sock_file' is not exists or is not a socket"

    cookie_file=$(get_host_xdg_config_dir pulse)/cookie
    [ -f "$cookie_file" ] ||
        die "PulseAudio cookie file '$cookie_file' is not found"
    cp "$cookie_file" "$spawn_runtime_dir/pulse_cookie"
    chmod 666 "$spawn_runtime_dir/pulse_cookie"

    PA_A="$PA_A$S$(make_env_arg "PULSE_SERVER=$target_runtime_dir/pulse_sock")"
    PA_A="$PA_A$S$(make_env_arg "PULSE_COOKIE=$target_runtime_dir/pulse_cookie")"

    case $spawn_type in
        *)
            PA_A="$PA_A$S$(make_bind_arg "$sock_file" "$target_runtime_dir/pulse_sock")"
            ;;
    esac

    eval "${1}=\"\$${1}$S$PA_A\""
}

setup_home_env() {
    local HOME_A= src= dest=

    [ "${bind_home-}"  ] || return 0

    src=${bind_home%:*}
    if [ "$src" != "$bind_home" ]; then
        dest=${bind_home#*:}
    fi
    : ${dest:=$spawn_home}

    [ -d "$src" ] ||
        die "the source directory to bind home does not exist: $src"
    if [ -z "$dest" ]; then
        if [ "$spawn_type" = "docker" ]; then
            die "could not find home directory to bind to: please specify a \
user existing inside the container by name"
        else
            die "failed to find home directory for user: $spawn_user_arg"
        fi
    fi

    case $spawn_type in
        *)
            HOME_A="$HOME_A$S$(make_bind_arg "$src" "$dest")"
            ;;
    esac

    eval "${1}=\"\$${1}$S$HOME_A\""
}

setup_bind_env() {
    local IFS="$S" OUT_A="$1" BIND_A= from to opt

    [ "${bind_dir_args-}" ] || return 0

    bind_dir_args=$(echo "$bind_dir_args" | sed "s|\\\\:|$Q|g")
    while IFS=: read from to opt; do
        from=$(echo "$from" | sed "s|$Q|\\\\:|g")
        to=$(echo "$to" | sed "s|$Q|\\\\:|g")
        to=${to:-$from}
        : ${spawn_wd:=$(eval echo "$to")}
        case $spawn_type in
            *)
                BIND_A="$BIND_A$S$(make_bind_arg "$from" "$to" "${opt-}")"
                ;;
        esac
    done <<EOF
${bind_dir_args-}
EOF

    if [ "${to-}" ]; then
        BIND_A="$BIND_A$S$(make_env_arg "WD=$to")"
    fi

    eval "${OUT_A}=\"\$${OUT_A}$S$BIND_A\""
}

setup_env() {
    add_user_arg        "$1"
    setup_caps          "$1"
    setup_devices       "$1"
    setup_runtime_env   "$1"
    setup_system_env    "$1"
    setup_ssh_agent_env "$1"
    setup_ssh_dir_env   "$1"
    setup_x11_env       "$1"
    setup_pa_env        "$1"
    setup_home_env      "$1"
    setup_bind_env      "$1"
}

extract_xauth() {
    # Use wildcard authentication family because hostname of container can
    # differ from the host and default Xauthority files are hostname specific.
    # See http://stackoverflow.com/a/25280523 for details.
    xauth nlist "$DISPLAY" | sed 's/^..../ffff/' | xauth -f "$1" nmerge -
}

unlock() {
    if [ "${spawn_dir-}" ]; then
        unlock_dir "$spawn_dir"
        sync
    fi
}

umount_all() {
    if [ "${spawn_dir-}" ]; then
        try_umount "$spawn_dir/sys" -R
        try_umount "$spawn_dir/dev" -R
        [ "${spawn_home-}" ] && try_umount "$spawn_dir$spawn_home"
        [ "${xsock_dir-}"  ] && try_umount "$spawn_dir$xsock_dir"
        try_umount "$spawn_dir/etc/localtime"
        try_umount "$spawn_dir/etc/resolv.conf"
    fi
    if [ "${spawn_runtime_dir-}" ]; then
        try_umount "$spawn_runtime_dir/pulse_sock"
        try_umount "$spawn_runtime_dir/ssh"
        rm -rf "$spawn_runtime_dir"
    fi
}

cleanup() {
    local IFS="$S"

    for path in $mountpoints; do
        su_run umount -R "$path" || true
    done
    if [ "${spawn_runtime_dir-}" ]; then
        rm -rf "$spawn_runtime_dir"
    fi

    unlock
}

spawn_root_nspawn() {
    local IFS="$S" A=

    trap cleanup EXIT

    # systemd-nspawn runs 'getent passwd <user>' inside the container to get
    # passwd entry for the user or fails with "Failed to resolve user <user>"

    setup_env A

    $E su_run systemd-nspawn $A ${spawn_args-} -D "$spawn_dir" -- /bin/sh -c "exec $(get_command)"
}

spawn_root_docker() {
    local IFS="$S" A= it_arg= cmd=

    trap cleanup EXIT

    setup_env A

    if [ -t 1 ]; then
        it_arg='-it'
    fi

    $E docker run --rm $it_arg \
        ${spawn_name:+--name=${spawn_name}} \
        ${share_ipc:+--ipc=host} \
        ${share_devices:+--privileged} \
        $A \
        ${spawn_args-} \
        "${spawn_image}" \
        $spawn_command

    # if [ "${spawn_command-}" ]; then
    #     $E docker run --rm $it_arg ${share_devices:+--privileged} \
    #         $A ${spawn_args-} "$spawn_image" $spawn_command
    # else
    #     it_arg="-it"
    #     $E docker run --rm $it_arg ${share_devices:+--privileged} \
    #         $A ${spawn_args-} "$spawn_image" /bin/sh -c "exec $(get_command)"
    # fi
}

spawn_root_podman() {
    local IFS="$S" A= it_arg= cmd=

    trap cleanup EXIT

    setup_env A

    if [ -t 1 ]; then
        it_arg='-it'
    fi

    $E podman run --rm $it_arg \
        ${share_devices:+--privileged} \
        ${spawn_name:+--name=${spawn_name}} \
        $A \
        ${spawn_args-} \
        "${spawn_image}" \
        $spawn_command
}

if [ $# = 0 ]; then
    show_usage
    exit 0
fi

parse_command_line "$@"
validate_environment

euid=${UID:-$(id -u)}

host_user_name=$(id -un)
host_user_uid=$(id -u)
host_user_gid=$(id -g)
host_user_home=${HOME-}

if [ "${spawn_user_arg:-}" ]; then
# read does not read from a pipe because it can be in a subshell
IFS=: read spawn_uid_arg spawn_gid_arg <<EOF
$spawn_user_arg
EOF

spawn_user_name=$(find_user_info name "$spawn_uid_arg" "${spawn_gid_arg-}") || true
spawn_user_uid=$(find_user_info uid "$spawn_uid_arg" "${spawn_gid_arg-}") || true
spawn_user_gid=$(find_user_info gid "$spawn_uid_arg" "${spawn_gid_arg-}") || true
spawn_home=$(find_user_info home "$spawn_uid_arg" "${spawn_gid_arg-}") || true
fi

: ${spawn_user_name:=$(id -un)}
: ${spawn_user_uid:=$(id -u)}
: ${spawn_user_gid:=$(id -g)}
: ${spawn_home:=${HOME-}}

if [ "${do_unlock-}" ]; then
    unlock; exit
fi
if [ "${do_cleanup-}" ]; then
    umount_all; unlock; exit
fi

if [ "${to_stderr-}" ]; then
    exec 1>&2
fi

case $spawn_type in
    docker)
        spawn_root_docker
        ;;
    podman)
        spawn_root_podman
        ;;
    nspawn)
        if [ "${spawn_dir-}" ]; then
            if is_locked "$spawn_dir"; then
                die "the directory '$spawn_dir' is locked by another spawn instance, \
                    use '--cleanup' option to remove stale locks"
            fi
            lock_dir "$spawn_dir"

            if [ "$spawn_type" = 'nspawn' ]; then
                spawn_root_nspawn
            fi
        else
            die "chroot directory is not specified"
        fi ;;
esac
